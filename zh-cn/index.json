[
{
	"uri": "https://ybilly.com/zh-cn/",
	"title": "Billy&#39;s",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/linux/",
	"title": "linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/2019/09/15/linux%E4%B8%8B%E9%BB%98%E8%AE%A4%E7%94%A8wps%E6%89%93%E5%BC%80office%E6%96%87%E4%BB%B6/",
	"title": "linux下默认用wps打开office文件",
	"tags": ["linux", "wps"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "问题 相信很多人都遇到过，每次更新wps后，都会发生.docx、.xlsx文件默认打开方式被修改的问题。直接点击打开office文件的话，会被认为是打开一个zip文件。只有通过右键菜单里面选择open with wps...这种方式才能正常使用wps打开。\n解决办法 在网上搜了一圈，确定是由于wps自己加了mime type定义的原因。\n具体可以ls /usr/share/mime/packages/查看一下，该目录下面应该会有几个wps-office-开头的文件，\n1 2 3 4  # 删除多余的mime type sudo rm /usr/share/mime/packages/wps-office-* # 更新 sudo update-mime-database /usr/share/mime   再单击打开.xlsx文件，发现已经可以正常默认使用wps打开了。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/wps/",
	"title": "wps",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/categories/%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/",
	"title": "使用经验",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/categories/",
	"title": "分类",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/",
	"title": "标签",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/categories/vps/",
	"title": "vps",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/vps/",
	"title": "vps",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/vultr/",
	"title": "vultr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/2019/04/07/vultr%E6%96%B0%E7%94%A8%E6%88%B7%E9%80%8150%E7%BE%8E%E9%87%91/",
	"title": "vultr新用户送50美金",
	"tags": ["vps", "vultr", "促销"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "刚才看 vultr 帐户时，发现 vultr 又有拉新活动，使用推荐码注册的 vultr 新用户，首次充值时，将获得 50 刀的奖励。也就是第一笔充 10 刀，最终获得 60 刀。\n有两种办法，\n 一是在注册前先用带推荐码的链接打开 vultr 的网站，比如像这样的：https://www.vultr.com/?ref=7995525-4F 第二种是在注册了帐号以后，首次充值时，输入推荐码，比如：7995525-4F，支持信用卡、支付宝、微信支付。  \n2019.4.20 还可用。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/tags/%E4%BF%83%E9%94%80/",
	"title": "促销",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/shadowsocks/",
	"title": "shadowsocks",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/v2ray/",
	"title": "v2ray",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/%E7%BF%BB%E5%A2%99/",
	"title": "翻墙",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/2019/01/06/%E9%80%9A%E7%94%A8%E7%BF%BB%E5%A2%99%E8%84%9A%E6%9C%AC/",
	"title": "通用翻墙脚本",
	"tags": ["v2ray", "shadowsocks", "golang", "翻墙"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "通用的翻墙脚本 比如我们在go get的时候，会遇到有些包要翻墙才能下载。在npm install的时候，node-sass有些文件要翻墙下载。这些工具都会依赖于环境变量里面的http_proxy或者https_proxy，需要翻墙的时候，只要设置好这些环境变量，工具就能翻墙了。但是针对每个工具写一个脚本并不是一种可以接受的方案，我们需要更通用的方案。\n参考ZeppLu的方案。\nWindows下的方案 在PATH目录下新建一个proxy.bat的批处理\n1 2 3 4 5 6 7 8 9 10  @echo off\rset http_proxy=socks5://127.0.0.1:1080\rset https_proxy=127.0.0.1:1081\r%*\recho ...\rpause\r  Linux下的方案 在.bashrc或者.profile（取决于你使用的tty）中增加以下设置\n1 2 3 4 5  alias socks=\u0026#39;ALL_PROXY=socks5://127.0.0.1:1080/ \\\rhttp_proxy=http://127.0.0.1:1081/ \\\rhttps_proxy=http://127.0.0.1:1081/ \\\rHTTP_PROXY=http://127.0.0.1:1081/ \\\rHTTPS_PROXY=http://127.0.0.1:1081/\u0026#39;\r  使用效果 1 2 3 4 5 6 7 8 9 10 11  \u0026gt;proxy go get -u -v golang.org/x/net\rFetching https://golang.org/x/net?go-get=1\rParsing meta tags from https://golang.org/x/net?go-get=1 (status code 200)\rget \u0026#34;golang.org/x/net\u0026#34;: found meta tag get.metaImport{Prefix:\u0026#34;golang.org/x/net\u0026#34;, VCS:\u0026#34;git\u0026#34;, RepoRoot:\u0026#34;https://go.googlesource.com/net\u0026#34;} at https://golang.org/x/net?go-get=1\rgo: finding golang.org/x/net latest\rFetching https://golang.org/x?go-get=1\rParsing meta tags from https://golang.org/x?go-get=1 (status code 200)\rFetching https://golang.org?go-get=1\rParsing meta tags from https://golang.org?go-get=1 (status code 200)\r...\r请按任意键继续. . .\r  1 2 3 4 5 6  ~ socks go get -u -v golang.org/x/crypto\rFetching https://golang.org/x/crypto?go-get=1\rParsing meta tags from https://golang.org/x/crypto?go-get=1 (status code 200)\rget \u0026#34;golang.org/x/crypto\u0026#34;: found meta tag get.metaImport{Prefix:\u0026#34;golang.org/x/crypto\u0026#34;, VCS:\u0026#34;git\u0026#34;, RepoRoot:\u0026#34;https://go.googlesource.com/crypto\u0026#34;} at https://golang.org/x/crypto?go-get=1\rgolang.org/x/crypto (download)\rpackage golang.org/x/crypto: no Go files in /e/project/go/src/golang.org/x/crypto\r  "
},
{
	"uri": "https://ybilly.com/zh-cn/tags/docker/",
	"title": "docker",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/2018/11/15/docker%E7%9A%84%E8%BF%81%E7%A7%BB/",
	"title": "docker容器的迁移",
	"tags": ["docker"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "前叙 原来在vultr买的vps内存有点小，准备留着备用，或者放弃掉。（2.5 美金的机器，现在已经绝种的套餐，放弃掉太可惜了。）\n另外准备了一台 1G 内存的vps，需要做的事情就是把以前的数据库、git数据、各种东西迁移过去。所幸全部应用都已经用docker实现了容器化，有用数据都放在volume里面。迁移起来非常方便。\n准备工作 原来的vps在vultr中，叫Src，新的vps叫Dest。分别建个目录做备份。\n1 2 3 4 5 6  # from Src\r:~$mkdir backup\r# from dest\r:~$mkdir backup\r  打包 我的数据都是放在 volume 里面的。首先是在Src中用一个container把volume加载。这个就个人随意了。\n然后将volume里面的东西打包\n1 2 3  # from Src\rsudo docker run -v /gogs --name store alpine /bin/ash\rsudo docker run --rm --volumes-from store -v $(pwd):/backup alpine tar czf /backup/gogs.tar.gz /volumes/gogs\r  传输 用 scp 将打包文件从Src下载到Dest中。\n1 2 3  cd ~/backup\rscp username@ipaddress:~/backup/gogs.tar.gz gogs.tar.gz\r  恢复 同样创建一个volume，然后用一个临时的container加载。然后解包。\n1 2 3 4  sudo docker volume create gogs\rsudo docker run -v /gogs --name store alpine /bin/ash\rsudo docker run --rm --volumes-from store -v $(pwd):/backup alpine ash -c \u0026#34;cd /volumes/gogs \u0026amp;\u0026amp; tar xzf /backup/gogs.tar.gz --strip 2\u0026#34;\r  all done.\n"
},
{
	"uri": "https://ybilly.com/zh-cn/tags/webpack/",
	"title": "webpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/2018/08/10/%E8%A7%A3%E5%86%B3webpack%E6%97%A0%E6%B3%95%E5%B0%86css%E6%89%93%E5%8C%85%E6%88%90%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/",
	"title": "解决webpack无法将css打包成单个文件的问题",
	"tags": ["webpack"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "遇到的问题 在打包一个旧项目的时候，遇到所有的css都丢失了的情况。检查文件发现没有导出style.css这个文件。\n按照打包配置，应该会把项目中所有的css整合成一个文件导出的，但是打包过程正常，style.css却没有导出。\n找了半天都没有找出问题，试了多种打包方案，把css拆开的、合在一起的、把extract-text-webpack-plugin插件换成mini-css-extract-plugin插件……\n整个打包过程没有任何错误提示，导致查错没有方向。\n是sideEffects的锅 最后在 stackoverflow 这个问题上受到了启发。\nNote that any imported file is subject to tree shaking. This means if you use something like css-loader in your project and import a CSS file, it needs to be added to the side effect list so it will not be unintentionally dropped in production mode.\nWebpack文档里面这样说：\nA \u0026quot;side effect\u0026quot; is defined as code that performs a special behavior when imported, other than exposing one or more exports. An example of this are polyfills, which affect the global scope and usually do not provide an export.\r\u0026quot;side effect\u0026quot;就是一段导入后执行特殊功能的代码，比如：`polyfills`的是直接作用在全局的，它并没有导出。\r 想起前几天尝试了一下sideEffects的作用，于是赶紧把它改回来。在项目的package.json里面找到sideEffects: false，直接删除掉。\n当然，也可以加入例外\n1 2 3  \u0026#34;sideEffects\u0026#34;: [\r\u0026#39;.scss\u0026#39;\r]\r  再打包，style.css回来了。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/07/20/2.4.0-webpack%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF%E5%92%8C%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/",
	"title": "2.4.0 webpack打包体积和速度优化",
	"tags": ["webpack"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "typescript的tree shaking 使用webpack打包typescript时，发现没有tree shaking。\n分析对比，发现是因为webpack支持的tsconfig配置文件中有说到要用：\u0026quot;module\u0026quot;: \u0026quot;CommonJS\u0026quot;,，\n但是在webpack中关于tree shaking的说明里面提到\nTree shaking is a term commonly used in the JavaScript context for dead-code elimination. It relies on the static structure of ES2015 module syntax, i.e. import and export. The name and concept have been popularized by the ES2015 module bundler rollup.\ntree shaking要用es2015的才行。所以要分开两个配置文件。tsconfig.json和tsconfig.webpack.json，其中tsconfig.webpack.json用来打包用。\ntsconfig.json\n1 2  \u0026#34;module\u0026#34;: \u0026#34;CommonJS\u0026#34;,\r\u0026#34;target\u0026#34;: \u0026#34;es2015\u0026#34;,\r  tsconfig.webpack.json\n1 2  \u0026#34;module\u0026#34;: \u0026#34;es2015\u0026#34;,\r\u0026#34;target\u0026#34;: \u0026#34;es2015\u0026#34;,\r  修改webpack.prod.conf.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  {\rtest: /\\.vue$/,\rloader: \u0026#39;vue-loader\u0026#39;,\roptions: {\rloaders: {\rts: \u0026#39;cache-loader!babel-loader!ts-loader?configFile=tsconfig.webpack.json\u0026#39;,\r// Since sass-loader (weirdly) has SCSS as its default parse mode, we map\r // the \u0026#34;scss\u0026#34; and \u0026#34;sass\u0026#34; values for the lang attribute to the right configs here.\r // other preprocessors should work out of the box, no loader config like this necessary.\r scss: \u0026#39;vue-style-loader!css-loader!sass-loader\u0026#39;,\rsass: \u0026#39;vue-style-loader!css-loader!sass-loader?indentedSyntax\u0026#39;,\r},\r// other vue-loader options go here\r },\rinclude: /src/,\rexclude: /node_modules\\/(?!(autotrack|dom-utils))|vendor\\.dll\\.js/,\r},\r{\rtest: /\\.tsx?$/,\rloader: \u0026#39;ts-loader\u0026#39;,\rexclude: /node_modules/,\rinclude: /src/,\roptions: {\rconfigFile: \u0026#34;tsconfig.webpack.json\u0026#34;,\rappendTsSuffixTo: [/\\.vue$/],\r},\r},\r  打包测试一下，app.js从12k减小到7k，变化明显。\n优化打包速度 使用dll插件可以优化打包速度，首先新建一个dll专用的打包配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  import * as OptimizeCSSAssetsPlugin from \u0026#39;optimize-css-assets-webpack-plugin\u0026#39;;\rimport * as path from \u0026#39;path\u0026#39;;\rimport * as UglifyJsPlugin from \u0026#39;uglifyjs-webpack-plugin\u0026#39;;\rimport * as webpack from \u0026#39;webpack\u0026#39;;\rmodule.exports = {\rmode: \u0026#39;development\u0026#39;,\rentry: {\rvendor: [\r\u0026#39;@fortawesome/fontawesome-svg-core\u0026#39;,\r\u0026#39;@fortawesome/free-solid-svg-icons\u0026#39;,\r\u0026#39;@fortawesome/vue-fontawesome\u0026#39;,\r\u0026#39;vue\u0026#39;,\r\u0026#39;element-ui\u0026#39;,\r\u0026#39;vue-router\u0026#39;,\r],\r},\routput: {\rpath: path.resolve(__dirname, \u0026#39;../static/js\u0026#39;),\rfilename: \u0026#39;[name].dll.js\u0026#39;,\rlibrary: \u0026#39;[name]_library\u0026#39;,\r},\rmodule: {\rrules: [\r{\rtest: /\\.vue$/,\rloader: \u0026#39;vue-loader\u0026#39;,\r},\r{\rtest: /\\.js$/,\rloader: \u0026#39;babel-loader\u0026#39;,\rexclude: /node_modules/,\r},\r{\rtest: /\\.tsx?$/,\rloader: \u0026#39;ts-loader\u0026#39;,\rexclude: /node_modules/,\r},\r],\r},\roptimization: {\rminimizer: [\rnew UglifyJsPlugin({\rcache: true,\rparallel: true,\rsourceMap: false, // set to true if you want JS source maps\r }),\rnew OptimizeCSSAssetsPlugin({}),\r],\r},\rplugins: [\rnew webpack.optimize.ModuleConcatenationPlugin(),\rnew webpack.DllPlugin({\rpath: path.join(__dirname, \u0026#39;../static/js\u0026#39;, \u0026#39;[name]-manifest.json\u0026#39;),\rname: \u0026#39;[name]_library\u0026#39;,\r}),\r],\r};\r  这个配置用来生成verdor.dll.js文件，然后修改webpack.prod.conf.ts配置，引用verdor.dll.js。\nplugins里面增加：\n1 2 3 4  new Webpack.DllReferencePlugin({\rcontext: __dirname,\rmanifest: require(\u0026#39;../static/js/vendor-manifest.json\u0026#39;),\r}),\r  先运行 webpack --config build/webpack.dll.conf.ts 生成dll，然后运行 cross-env NODE_ENV=production webpack --config build/webpack.prod.conf.ts。\n测试打包速度比之前快了几秒钟。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/categories/%E5%AD%A6%E4%B9%A0vue/",
	"title": "学习vue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/2018/07/15/2.3.0-production%E6%89%93%E5%8C%85/",
	"title": "2.3.0 production打包",
	"tags": ["vue", "webpack", "elementui", "typescript"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "这几天准备研究一下，webpack怎么找包发布项目。\n打包需求：  包要尽量小； 打包速度尽量快； 自动打包静态文件；  打包测试 新增一个配置文件 webpack.prod.conf\n1 2 3 4 5 6 7 8 9 10  import * as Webpack from \u0026#39;webpack\u0026#39;;\rimport * as merge from \u0026#39;webpack-merge\u0026#39;;\rimport { config } from \u0026#39;./webpack.conf\u0026#39;;\rexport const prodConfig: Webpack.Configuration = merge.smart(config, {\rmode: \u0026#39;production\u0026#39;,\r})\rexport default prodConfig;\r  package.json 中添加命令\n1 2 3  \u0026#34;scripts\u0026#34;:{\r\u0026#34;build:prod\u0026#34;: \u0026#34;webpack --config build/webpack.prod.conf.ts\u0026#34;,\r}\r  打包完成后，生成的 app.js 有 8.47M，有点大。\n去掉sourcemap 首先想到的是去掉 sourceMap。添加配置\n1  devtool: false,\r  打包出来的结果\n1  app.js 2.2M\r  分离css样式 使用 extract-text-webpack-plugin 插件\n1  npm i -D extract-text-webpack-plugin @types/extract-text-webpack-plugin\r  打包出来的结果\n1 2  app.js 1,298,009\rcss/style.css 969,886\r  尝试优化一下css 1  npm i -D optimize-css-assets-webpack-plugin @types/optimize-css-assets-webpack-plugin\r  webpack的minimizer中添加：\n1 2 3  new OptimizeCSSPlugin({\rcssProcessorOptions: { map: { inline: false }, discardComments: { removeAll: true } },\r}),\r  打包出来：\n1 2  app.js 1,298,009\rcss/style.css 184,234\r  处理app.js 现在打包出来的js是一个大文件，先按模块折开\n折分app.js 想法是将所有第三方库合并成一个 verdor.js，因为项目现在不太大，可以这样做。\n添加splitChunks配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  optimization:{\r//添加splitChunks配置\r splitChunks: {\r// chunks: \u0026#34;initial\u0026#34;，\u0026#34;async\u0026#34;和\u0026#34;all\u0026#34;分别是：初始块，按需块或所有块；\r chunks: \u0026#39;all\u0026#39;,\r// （默认值：30000）块的最小大小\r minSize: 30000,\r// （默认值：1）分割前共享模块的最小块数\r minChunks: 1,\r// （缺省值5）按需加载时的最大并行请求数\r maxAsyncRequests: 8,\r// cacheGroups is an object where keys are the cache group names.\r name: true,\rcacheGroups: {\rvendors: {\rtest: /[\\\\/]node_modules[\\\\/]/,\rname: \u0026#39;verdors\u0026#39;,\r},\r},\r},\r}\r  打包出来：\n1 2 3  app.js 7,608\rverdor.js 729,515\rcss/style.css 184,234\r  "
},
{
	"uri": "https://ybilly.com/zh-cn/tags/elementui/",
	"title": "elementUI",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/typescript/",
	"title": "typescript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/vue/",
	"title": "vue",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/",
	"title": "观察者模式",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/2018/07/10/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/",
	"title": "观察者模式与订阅-发布模式的区别",
	"tags": ["观察者模式", "订阅-发布模式", "软件模式"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " 观察者模式与订阅-发布模式的区别是什么  观察者模式 订阅-发布模式 延伸    观察者模式与订阅-发布模式的区别是什么 有人说：“订阅-发者模式=观察者模式”，这么理解的人，是因为订阅-发布模式这个名字取的太简洁。\n完整的解读订阅-发布模式，应该叫订阅-分发-发布模式。\n观察者模式涉及的角色：订阅者、观察者和目标；而订阅-分发-发布模式涉及的角色：订阅者、发布者和分发器。注意取名的不同表示他们执行的逻辑不同。\n 订阅者：不用解释了。 观察者：观察目标的状态，然后将结果告诉订阅者。 目标：完全是群众演员。 发布者：将自己的信息或状态告诉分发器，nothing more。 分发器：将发布者告诉自己的信息转告给订阅者，so simple。  这么一说应该已经很明确了。各个角色的定位和逻辑是不同。由于逻辑和功能的不同，导致这两种模式的应用场景也不同。\n我们用现实的例子来说明吧。\n观察者模式 你在路上看到蚂蚁搬家，想知道它们什么时候搬完，但是又又不想一直这么无聊的盯。所以你找个小孩，给他一块糖，叫他帮你看，好了打电话告诉你。然后你就回寝室打农药了。\n小孩就是观察者，蚂蚁搬家就是目标，你是订阅者。应用场景直观明了。\n后来，你又看到一窝蚂蚁，只好又叫个小孩。因为职能必须唯一，当然我们不可以叫单个小孩一个人看两。\n后来，又叫了个小孩……又叫了个小孩……又叫了个……\n小孩多还不是麻烦，麻烦大的是，有一天，隔壁老王对这个小孩说，也通知我一下，隔壁老李对另一个小孩说，也通知我一下……\n每个小孩要通知100个人，你等着100个小孩通知你。如果有1000个……10000个……\n订阅-发布模式 这个时候就要另一个模式出场了。有个孩子王还是很有头脑的。他对所有小孩说，你们看着蚂蚁搬家，有结果就告诉他。然后你对其它人说，谁想知道蚂蚁搬家最新进展的来我这里登记一下姓名、年龄、爱好和蚂蚁窝的编号。这时，小孩是发布者，孩子王是分发器，你和老王老李是订阅者。\n延伸 然后孩子王又给老王老李他们两种选择，一种是等他来打电话给老王老李，另一种是隔一段时间老王老李打电话找他问，这就是push和pull了。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/tags/%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/",
	"title": "订阅-发布模式",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/tags/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F/",
	"title": "软件模式",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/2018/07/03/go-get%E5%88%A9%E7%94%A8ss%E7%9B%B4%E6%8E%A5%E7%BF%BB%E5%A2%99/",
	"title": "go-get 利用 socks5 代理翻墙下载",
	"tags": ["shadowsocks", "golang", "翻墙"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "新版通用脚本 Updated: 2019-01-06，新增更通用的脚本方法：传送门·通用翻墙脚本\ngit config 配置代理在go get命令中无效 go get 下载软件包时遇到的翻墙问题确实很烦人。而且 git config 里面配的代理也是会导致go get失败的。\n因为当你使用 go get golang.org/x/crypto 时，需要先访问 https://golang.org/x/crypto?go-get=1 来获取版本库的类型是 git 或 svn 或是其它 。这个阶段 git config 配置的代理是不起作用的。所以 go get就会失败。\n直接使用 ss 的 socks5 代理 在 windows 环境中，网上以前的经验是使用一个软件把 ss 的 socks5 代理转成 http 代理，然后使用 set http_proxy=http://127.0.0.1:1081 这样来达到目的。\n实际上不需要那么麻烦，经过测试，go get命令直接就可以支持 socks5 代理。\n新建一个批处理 goget.bat，放到 PATH 环境下。脚本如下：\n1 2 3 4 5 6 7 8 9 10  @echo off\rset http_proxy=socks5://127.0.0.1:1080\rset https_proxy=socks5://127.0.0.1:1080\rgo get -u -v %*\recho ...\rpause\r  使用的时候直接打开命令行输入 goget golang.org/x/crypto 来看看效果。\n1 2 3 4 5 6 7 8  e:\\project\\go\\src\u0026gt;goget golang.org/x/crypto\r Fetching https://golang.org/x/crypto?go-get=1\rParsing meta tags from https://golang.org/x/crypto?go-get=1 (status code 200)\rget \u0026#34;golang.org/x/crypto\u0026#34;: found meta tag get.metaImport{Prefix:\u0026#34;golang.org/x/crypto\u0026#34;, VCS:\u0026#34;git\u0026#34;, RepoRoot:\u0026#34;https://go.googlesource.com/crypto\u0026#34;} at https://golang.org/x/crypto?go-get=1\rgolang.org/x/crypto (download)\rpackage golang.org/x/crypto: no Go files in E:\\project\\go\\src\\golang.org\\x\\crypto\r...\r请按任意键继续. . .\r  这下完美了。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/06/20/2.2.0-%E4%BD%BF%E7%94%A8vue%E7%9A%84router%E8%B7%B3%E8%BD%AC/",
	"title": "2.2.0 使用vue的router跳转",
	"tags": ["vue", "webpack", "elementui", "typescript"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "增加router模块 在 src/router 目录下新建 index.ts, 用来定义整个页面的路由。\n1 2 3 4 5 6 7 8 9 10 11 12  import Vue from \u0026#39;vue\u0026#39;;\rimport VueRouter, { RouteConfig } from \u0026#39;vue-router\u0026#39;;\rVue.use(VueRouter);\rimport Layout from \u0026#39;@/views/layout/index.vue\u0026#39;;\rexport const staticRouter: RouteConfig[] = [\r{\rpath: \u0026#39;/\u0026#39;, component: Layout, redirect: \u0026#39;dashboard\u0026#39;\r}\r]\r  然后在 src/index.ts 里面需要把 router 引入。\n1 2 3 4 5 6 7  import router from \u0026#39;@/router\u0026#39;;\rconst v = new Vue({\rel: \u0026#39;#app\u0026#39;,\rrouter,\r......\r});\r  新建页面 Layout 在 src/views/layout 目录下新建 index.vue, 用来定义整个页面的模板。\n先做个简单的页面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026#34;app-wrapper\u0026#34;\u0026gt;\r\u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Index\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;a href=\u0026#34;/pages\u0026#34;\u0026gt;Pages\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\r\u0026lt;a href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt;\rimport { Vue, Prop, Component } from \u0026#34;vue-property-decorator\u0026#34;;\rexport default class Layout extends Vue {}\r\u0026lt;/script\u0026gt;\r  运行一下看结果。可以正常导航了。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/06/10/2.1.0-vue%E5%8D%95%E9%A1%B5%E5%B7%A5%E7%A8%8B/",
	"title": "2.1.0 Vue单页工程",
	"tags": ["vue", "webpack", "elementui", "typescript"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "安装依赖 我们需要 vue-property-decorator 来引入 Prop 和 Component。\n1  npm i -s vue-property-decorator\r  Vue单页工程 在 src 目录下新建 app.vue文件\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;template\u0026gt;\r\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\r\u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt;\rimport { Vue, Prop, Component } from \u0026#34;vue-property-decorator\u0026#34;;\r@Component\rexport default class AppComponent extends Vue {}\r\u0026lt;/script\u0026gt;\r  修改 index.ts 中的内容\n1 2 3 4 5 6 7 8 9 10  import AppComponent from \u0026#39;@/app.vue\u0026#39;;\rconst v = new Vue({\r...\rtemplate: `\u0026lt;app-component\u0026gt;\u0026lt;/app-component\u0026gt;`,\rcomponents: {\rAppComponent,\r},\r...\r});\r  这里发现在，提示：“[ts] 找不到模块“@/app.vue”。” 这是因为我们没有告诉 typescript 如何处理 .vue 文件。\n这里我们新建一个 vue-shims.d.ts\n1 2 3 4  declare module \u0026#34;*.vue\u0026#34; {\rimport Vue from \u0026#34;vue\u0026#34;;\rexport default Vue;\r}\r  这样错误提示就解决了。\nnpm start 预览一下。Hello World。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/06/03/2.0.0-webpack%E6%89%93%E5%8C%85/",
	"title": "2.0.0 webpack打包",
	"tags": ["vue", "webpack"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "安装其它包 打包插件 1  npm i -D vue-loader ts-loader cache-loader style-loader css-loader url-loader file-loader html-webpack-plugin vue-template-compiler\r  为了使用 .ts 格式的 webpack 配置 1  npm i -D ts-node @types/html-webpack-plugin @types/node @types/webpack @types/webpack-merge\r  babel相关的包 1  npm i -D @babel/core @babel/preset-typescript babel-loader\r  显示 webpack 打包进度 安装包 1  npm i -D chalk progress-bar-webpack-plugin\r  这里要注意，会提示：“无法找到模块“progress-bar-webpack-plugin”的声明文件。”\n因为用的是typescript，所以需要有声明文件，也就是常见的.d.ts文件，网上没有现成的，我们需要自己手动写一个。把声明文件放到前面我们在tsconfig.json里面定义的types目录里面。\n在types目录新建文件夹progress-bar-webpack-plugin，然后在里面新建文件index.d.ts。\n1 2 3 4 5 6 7 8 9 10 11 12  import { Plugin } from \u0026#39;webpack\u0026#39;;\rexport = ProgressBarPlugin;\rdeclare namespace ProgressBarPlugin {\rinterface ProgressBarOptions {\rformat: string;\r}\r}\rdeclare class ProgressBarPlugin extends Plugin {\rconstructor(options?: ProgressBarPlugin.ProgressBarOptions);\r}\r  有了这个定义就不会报错了。\n准备webpack配置 build 目录下新建文件 webpack.conf.ts，具体内容太长就不复制了，直接在项目中看吧。\n脚本 在package.json里面增加脚本：\n1 2 3 4  \u0026#34;scripts\u0026#34;: {\r\u0026#34;start\u0026#34;: \u0026#34;webpack-dev-server --config build/webpack.conf.ts\u0026#34;,\r\u0026#34;build:dev\u0026#34;: \u0026#34;webpack --config build/webpack.conf.ts\u0026#34;\r},\r  测试 完成以上工作，开发环境就算准备好了。\n在工程根目录新建一个index.html模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!doctype html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\r\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge,chrome=1\u0026#34;\u0026gt;\r\u0026lt;meta name=\u0026#34;renderer\u0026#34; content=\u0026#34;webkit\u0026#34;\u0026gt;\r\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;\r\u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt;\r\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  在src目录新建index.ts：\n1 2 3 4 5 6 7 8 9 10 11 12 13  import Vue from \u0026#39;vue\u0026#39;;\rimport ElementUI from \u0026#39;element-ui\u0026#39;;\rimport \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;;\rVue.use(ElementUI);\rconst v = new Vue({\rel: \u0026#39;#app\u0026#39;,\rtemplate: `\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;`,\rcomponents: {\r},\r});\r  然后运行 npm run start\n打开 http://localhost:9000 看一下。\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/06/01/1.0.0-%E5%87%86%E5%A4%87%E5%B7%A5%E7%A8%8B/",
	"title": "1.0.0 准备工程",
	"tags": ["vue", "webpack", "elementui", "typescript"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "创建新工程 1 2 3  mkdir vue-learning\rcd vue-learning\rnpm init\r  安装 vue \u0026amp;\u0026amp; vuex \u0026amp;\u0026amp; element-ui 1  npm i -s vue vuex vue-router element-ui\r  webpack \u0026amp;\u0026amp; typescript 1  npm i -D webpack typescript tslint webpack-dev-server\r  配置 配置 vscode vscode 安装插件 vetur 和 tslint\n编辑项目工程下的配置文件 .vscode/setting.json，没有可以自己加个\n1 2 3 4 5 6 7 8 9 10 11 12 13  // Place your settings in this file to overwrite default and user settings.\r{\r\u0026#34;files.associations\u0026#34;: {\r\u0026#34;*.vue\u0026#34;: \u0026#34;vue\u0026#34;\r},\r// 保存文件时自动格式化一下，强迫症。\r\u0026#34;editor.formatOnSave\u0026#34;: true,\r// .vue文件里面的 \u0026lt;template\u0026gt; 段用默认的html工具格式化\r\u0026#34;vetur.format.defaultFormatter.html\u0026#34;: \u0026#34;js-beautify-html\u0026#34;,\r// tslint默认会自动修复格式，这个功能要关掉，只开启特定的功能\r\u0026#34;tslint.autoFixOnSave\u0026#34;: [\u0026#34;ordered-imports\u0026#34;, \u0026#34;eofline\u0026#34;, \u0026#34;no-consecutive-blank-lines\u0026#34;],\r}\r  说明一下：\n ordered-imports：ts 文件里面的 import 要按字母顺序，这个老提示很烦，保存的时候自动排一下就好 eofline：ts yy 文件最后一行必须是空行，自动改吧 no-consecutive-blank-lines：不能连着两个空行，自动改吧  配置 tsconfig.json 在项目根目录新建一个文件 tsconfig.json，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  {\r\u0026#34;compilerOptions\u0026#34;: {\r\u0026#34;outDir\u0026#34;: \u0026#34;./built/\u0026#34;,\r\u0026#34;sourceMap\u0026#34;: true,\r\u0026#34;strict\u0026#34;: true,\r\u0026#34;module\u0026#34;: \u0026#34;CommonJS\u0026#34;,\r\u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;,\r\u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;,\r\u0026#34;experimentalDecorators\u0026#34;: true,\r\u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;,\r\u0026#34;paths\u0026#34;: {\r\u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;],\r\u0026#34;*\u0026#34;: [\u0026#34;types/*\u0026#34;]\r}\r},\r\u0026#34;include\u0026#34;: [\r\u0026#34;./src/**/*\u0026#34;\r],\r\u0026#34;exclude\u0026#34;: [\r\u0026#34;node_modules\u0026#34;,\r\u0026#34;**/*.spec.ts\u0026#34;\r]\r}\r   说明：path字段可以用来定义引用别名，目录结构复杂的项目必用，谁用谁知道。  好了，初始的工程准备好了，后面我们来配置webpack的打包\n"
},
{
	"uri": "https://ybilly.com/zh-cn/2018/02/03/%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99/",
	"title": "优化网站",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": " 使用浏览器缓存 https://developers.google.com/speed/pagespeed/insights/  "
},
{
	"uri": "https://ybilly.com/zh-cn/archives/",
	"title": "Archives",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/series/",
	"title": "专栏",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ybilly.com/zh-cn/about/",
	"title": "关于",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]