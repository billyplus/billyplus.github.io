<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>使用经验 on 长孙叔叔的次世界</title>
    <link>https://ybilly.com/categories/%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</link>
    <description>Recent content in 使用经验 on 长孙叔叔的次世界</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 06 Jan 2019 17:25:00 +0000</lastBuildDate>
    
	<atom:link href="https://ybilly.com/categories/%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>通用翻墙脚本</title>
      <link>https://ybilly.com/2019/01/06/%E9%80%9A%E7%94%A8%E7%BF%BB%E5%A2%99%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Sun, 06 Jan 2019 17:25:00 +0000</pubDate>
      
      <guid>https://ybilly.com/2019/01/06/%E9%80%9A%E7%94%A8%E7%BF%BB%E5%A2%99%E8%84%9A%E6%9C%AC/</guid>
      <description>&lt;h1 id=&#34;通用的翻墙脚本&#34;&gt;通用的翻墙脚本&lt;/h1&gt;

&lt;p&gt;比如我们在go get的时候，会遇到有些包要翻墙才能下载。在npm install的时候，node-sass有些文件要翻墙下载。这些工具都会依赖于环境变量里面的&lt;code&gt;http_proxy&lt;/code&gt;或者&lt;code&gt;https_proxy&lt;/code&gt;，需要翻墙的时候，只要设置好这些环境变量，工具就能翻墙了。但是针对每个工具写一个脚本并不是一种可以接受的方案，我们需要更通用的方案。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/Microsoft/WSL/issues/2122#issuecomment-302153759&#34;&gt;ZeppLu&lt;/a&gt;的方案。&lt;/p&gt;

&lt;h1 id=&#34;windows下的方案&#34;&gt;Windows下的方案&lt;/h1&gt;

&lt;p&gt;在&lt;code&gt;PATH&lt;/code&gt;目录下新建一个&lt;code&gt;proxy.bat&lt;/code&gt;的批处理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bat&#34; data-lang=&#34;bat&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bat&#34; data-lang=&#34;bat&#34;&gt;&lt;span class=&#34;p&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;echo&lt;/span&gt; off

&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;http_proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;socks5&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;//127.0.0.1&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;:1080&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;https_proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;127.0.0.1&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;1081&lt;/span&gt;

&lt;span class=&#34;nv&#34;&gt;%*&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;echo&lt;/span&gt; ...

pause&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>docker容器的迁移</title>
      <link>https://ybilly.com/2018/11/15/docker%E7%9A%84%E8%BF%81%E7%A7%BB/</link>
      <pubDate>Thu, 15 Nov 2018 15:28:58 +0000</pubDate>
      
      <guid>https://ybilly.com/2018/11/15/docker%E7%9A%84%E8%BF%81%E7%A7%BB/</guid>
      <description>&lt;h1 id=&#34;前叙&#34;&gt;前叙&lt;/h1&gt;

&lt;p&gt;原来在&lt;code&gt;vultr&lt;/code&gt;买的&lt;code&gt;vps&lt;/code&gt;内存有点小，准备留着备用，或者放弃掉。（2.5 美金的机器，现在已经绝种的套餐，放弃掉太可惜了。）&lt;/p&gt;

&lt;p&gt;另外准备了一台 1G 内存的&lt;code&gt;vps&lt;/code&gt;，需要做的事情就是把以前的&lt;code&gt;数据库&lt;/code&gt;、&lt;code&gt;git数据&lt;/code&gt;、各种东西迁移过去。所幸全部应用都已经用&lt;code&gt;docker&lt;/code&gt;实现了容器化，有用数据都放在&lt;code&gt;volume&lt;/code&gt;里面。迁移起来非常方便。&lt;/p&gt;

&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;

&lt;p&gt;原来的&lt;code&gt;vps&lt;/code&gt;在&lt;code&gt;vultr&lt;/code&gt;中，叫&lt;code&gt;Src&lt;/code&gt;，新的&lt;code&gt;vps&lt;/code&gt;叫&lt;code&gt;Dest&lt;/code&gt;。分别建个目录做备份。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# from Src&lt;/span&gt;
:~&lt;span class=&#34;nv&#34;&gt;$mkdir&lt;/span&gt; backup


&lt;span class=&#34;c1&#34;&gt;# from dest&lt;/span&gt;
:~&lt;span class=&#34;nv&#34;&gt;$mkdir&lt;/span&gt; backup&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>解决webpack无法将css打包成单个文件的问题</title>
      <link>https://ybilly.com/2018/08/10/%E8%A7%A3%E5%86%B3webpack%E6%97%A0%E6%B3%95%E5%B0%86css%E6%89%93%E5%8C%85%E6%88%90%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 10 Aug 2018 16:24:58 +0000</pubDate>
      
      <guid>https://ybilly.com/2018/08/10/%E8%A7%A3%E5%86%B3webpack%E6%97%A0%E6%B3%95%E5%B0%86css%E6%89%93%E5%8C%85%E6%88%90%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h1&gt;

&lt;p&gt;在打包一个旧项目的时候，遇到所有的&lt;code&gt;css&lt;/code&gt;都丢失了的情况。检查文件发现没有导出&lt;code&gt;style.css&lt;/code&gt;这个文件。&lt;/p&gt;

&lt;p&gt;按照打包配置，应该会把项目中所有的&lt;code&gt;css&lt;/code&gt;整合成一个文件导出的，但是打包过程正常，&lt;code&gt;style.css&lt;/code&gt;却没有导出。&lt;/p&gt;

&lt;p&gt;找了半天都没有找出问题，试了多种打包方案，把&lt;code&gt;css&lt;/code&gt;拆开的、合在一起的、把&lt;code&gt;extract-text-webpack-plugin&lt;/code&gt;插件换成&lt;code&gt;mini-css-extract-plugin&lt;/code&gt;插件……&lt;/p&gt;

&lt;p&gt;整个打包过程没有任何错误提示，导致查错没有方向。&lt;/p&gt;

&lt;h1 id=&#34;是sideeffects的锅&#34;&gt;是sideEffects的锅&lt;/h1&gt;

&lt;p&gt;最后在 &lt;a href=&#34;https://stackoverflow.com/questions/50416293/webpack-minicssextractplugin-doesnt-extract-file&#34;&gt;stackoverflow&lt;/a&gt; 这个问题上受到了启发。&lt;/p&gt;

&lt;p&gt;Note that any imported file is subject to tree shaking. This means if you use something like css-loader in your project and import a CSS file, it needs to be added to the side effect list so it will not be unintentionally dropped in production mode.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt;文档里面这样说：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;A &amp;#34;side effect&amp;#34; is defined as code that performs a special behavior when imported, other than exposing one or more exports. An example of this are polyfills, which affect the global scope and usually do not provide an export.

&amp;#34;side effect&amp;#34;就是一段导入后执行特殊功能的代码，比如：`polyfills`的是直接作用在全局的，它并没有导出。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>观察者模式与订阅-发布模式的区别</title>
      <link>https://ybilly.com/2018/07/10/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 10 Jul 2018 14:24:58 +0000</pubDate>
      
      <guid>https://ybilly.com/2018/07/10/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;观察者模式与订阅-发布模式的区别是什么&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&#34;&gt;&lt;code&gt;观察者模式&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F&#34;&gt;&lt;code&gt;订阅-发布模式&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%B6%E4%BC%B8&#34;&gt;延伸&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;观察者模式与订阅-发布模式的区别是什么&#34;&gt;观察者模式与订阅-发布模式的区别是什么&lt;/h1&gt;

&lt;p&gt;有人说：“&lt;code&gt;订阅-发者模式&lt;/code&gt;=&lt;code&gt;观察者模式&lt;/code&gt;”，这么理解的人，是因为&lt;code&gt;订阅-发布模式&lt;/code&gt;这个名字取的太简洁。&lt;/p&gt;

&lt;p&gt;完整的解读&lt;code&gt;订阅-发布模式&lt;/code&gt;，应该叫&lt;code&gt;订阅-分发-发布模式&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;观察者模式&lt;/code&gt;涉及的角色：&lt;code&gt;订阅者&lt;/code&gt;、&lt;code&gt;观察者&lt;/code&gt;和&lt;code&gt;目标&lt;/code&gt;；而&lt;code&gt;订阅-分发-发布模式&lt;/code&gt;涉及的角色：&lt;code&gt;订阅者&lt;/code&gt;、&lt;code&gt;发布者&lt;/code&gt;和&lt;code&gt;分发器&lt;/code&gt;。注意取名的不同表示他们执行的逻辑不同。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;订阅者&lt;/code&gt;：不用解释了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;观察者&lt;/code&gt;：观察目标的状态，然后将结果告诉订阅者。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;目标&lt;/code&gt;：完全是群众演员。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;发布者&lt;/code&gt;：将自己的信息或状态告诉分发器，nothing more。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;分发器&lt;/code&gt;：将发布者告诉自己的信息转告给订阅者，so simple。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这么一说应该已经很明确了。各个角色的定位和逻辑是不同。由于逻辑和功能的不同，导致这两种模式的应用场景也不同。&lt;/p&gt;

&lt;p&gt;我们用现实的例子来说明吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go-get 利用 socks5 代理翻墙下载</title>
      <link>https://ybilly.com/2018/07/03/go-get%E5%88%A9%E7%94%A8ss%E7%9B%B4%E6%8E%A5%E7%BF%BB%E5%A2%99/</link>
      <pubDate>Tue, 03 Jul 2018 15:28:58 +0000</pubDate>
      
      <guid>https://ybilly.com/2018/07/03/go-get%E5%88%A9%E7%94%A8ss%E7%9B%B4%E6%8E%A5%E7%BF%BB%E5%A2%99/</guid>
      <description>&lt;h1 id=&#34;git-config-配置代理在-go-get-命令中无效&#34;&gt;&lt;code&gt;git config&lt;/code&gt; 配置代理在&lt;code&gt;go get&lt;/code&gt;命令中无效&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; 下载软件包时遇到的翻墙问题确实很烦人。而且 &lt;code&gt;git config&lt;/code&gt; 里面配的代理也是会导致&lt;code&gt;go get&lt;/code&gt;失败的。&lt;/p&gt;

&lt;p&gt;因为当你使用 &lt;code&gt;go get golang.org/x/crypto&lt;/code&gt; 时，需要先访问 &lt;code&gt;https://golang.org/x/crypto?go-get=1&lt;/code&gt; 来获取版本库的类型是 &lt;code&gt;git&lt;/code&gt; 或 &lt;code&gt;svn&lt;/code&gt; 或是其它 。这个阶段 &lt;code&gt;git config&lt;/code&gt; 配置的代理是不起作用的。所以 &lt;code&gt;go get&lt;/code&gt;就会失败。&lt;/p&gt;

&lt;h1 id=&#34;直接使用-ss-的-socks5-代理&#34;&gt;直接使用 &lt;code&gt;ss&lt;/code&gt; 的 &lt;code&gt;socks5&lt;/code&gt; 代理&lt;/h1&gt;

&lt;p&gt;在 windows 环境中，网上以前的经验是使用一个软件把 &lt;code&gt;ss&lt;/code&gt; 的 &lt;code&gt;socks5&lt;/code&gt; 代理转成 &lt;code&gt;http&lt;/code&gt; 代理，然后使用 &lt;code&gt;set http_proxy=http://127.0.0.1:1081&lt;/code&gt; 这样来达到目的。&lt;/p&gt;

&lt;p&gt;实际上不需要那么麻烦，经过测试，&lt;code&gt;go get&lt;/code&gt;命令直接就可以支持 &lt;code&gt;socks5&lt;/code&gt; 代理。&lt;/p&gt;

&lt;p&gt;新建一个批处理 &lt;code&gt;goget.bat&lt;/code&gt;，放到 &lt;code&gt;PATH&lt;/code&gt; 环境下。脚本如下：&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>